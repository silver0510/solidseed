import { createClient, SupabaseClient } from '@supabase/supabase-js';
import type {
  Client,
  ClientWithCounts,
  CreateClientInput,
  UpdateClientInput,
  ListClientsParams,
  PaginatedClients
} from '@/lib/types/client';

/**
 * Create Supabase admin client with service role key
 * This bypasses RLS policies - only use on server side
 */
function createSupabaseAdmin(): SupabaseClient {
  const url = process.env.NEXT_PUBLIC_SUPABASE_URL;
  const serviceRoleKey = process.env.SUPABASE_SERVICE_ROLE_KEY;

  if (!url || !serviceRoleKey) {
    throw new Error('Missing NEXT_PUBLIC_SUPABASE_URL or SUPABASE_SERVICE_ROLE_KEY');
  }

  return createClient(url, serviceRoleKey, {
    auth: {
      autoRefreshToken: false,
      persistSession: false,
    },
  });
}

/**
 * ClientService handles all client-related database operations
 *
 * Features:
 * - CRUD operations for client records
 * - Cursor-based pagination for efficient list queries
 * - Full-text search across client fields
 * - Tag-based filtering
 * - Soft delete with RLS policy enforcement
 *
 * Uses Supabase for data persistence with Row Level Security (RLS) policies
 * ensuring users can only access their own clients.
 *
 * @example
 * ```typescript
 * const clientService = new ClientService();
 *
 * // Create a new client
 * const client = await clientService.createClient({
 *   name: "John Doe",
 *   email: "john@example.com"
 * });
 *
 * // List clients with pagination
 * const result = await clientService.listClients({ limit: 20 });
 * ```
 */
export class ClientService {
  private supabase: SupabaseClient;

  /**
   * Initialize ClientService with admin Supabase client
   * Uses service role key to bypass RLS - only use on server side
   *
   * @throws {Error} If Supabase credentials are not configured
   */
  constructor() {
    this.supabase = createSupabaseAdmin();
  }

  /**
   * Create a new client
   *
   * @param data - Client data to create
   * @param userId - The authenticated user's ID (required, from Better Auth session)
   * @returns Promise<Client> The created client record
   * @throws {Error} If user ID is not provided
   * @throws {Error} If email or phone already exists
   * @throws {Error} If database operation fails
   *
   * @example
   * ```typescript
   * const client = await clientService.createClient({
   *   name: "John Doe",
   *   email: "john@example.com",
   *   phone: "+1-555-123-4567"
   * }, userId);
   * ```
   */
  async createClient(data: CreateClientInput, userId: string): Promise<Client> {
    if (!userId) {
      throw new Error('User ID is required');
    }

    // Extract tags from data (they're not part of the clients table)
    const { tags, ...clientData } = data;

    // Insert client into database (UUID auto-generated by PostgreSQL)
    const { data: client, error } = await this.supabase
      .from('clients')
      .insert({
        ...clientData,
        created_by: userId,
        assigned_to: userId,
        is_deleted: false,
      })
      .select()
      .single();

    if (error) {
      // Check for unique constraint violation (duplicate email/phone)
      if (error.code === '23505') {
        throw new Error('Email or phone already exists');
      }
      throw new Error(error.message);
    }

    // Add tags if provided
    if (tags && tags.length > 0 && client) {
      const tagRecords = tags.map((tagName: string) => ({
        client_id: client.id,
        tag_name: tagName,
        created_by: userId,
      }));

      const { error: tagError } = await this.supabase
        .from('client_tags')
        .insert(tagRecords);

      if (tagError) {
        // Log error but don't fail the request (tags are optional)
        console.error('Failed to add tags:', tagError);
      }
    }

    return client;
  }

  /**
   * List clients with pagination, search, and filtering
   *
   * Supports cursor-based pagination for efficient browsing of large datasets.
   * Results are filtered by user ownership and exclude soft-deleted clients.
   *
   * @param params - Query parameters for filtering and pagination
   * @param userId - The authenticated user's ID (required for authorization)
   * @returns Promise<PaginatedClients> Paginated client list with total count and next cursor
   * @throws {Error} If database query fails
   */
  async listClients(params: ListClientsParams, userId: string): Promise<PaginatedClients> {
    if (!userId) {
      throw new Error('User ID is required');
    }

    // Handle special filters with custom queries
    if (params.special_filter === 'need-followup') {
      return this.listClientsNeedFollowup(params, userId);
    }
    if (params.special_filter === 'birthdays-soon') {
      return this.listClientsBirthdaysSoon(params, userId);
    }

    // Validate and enforce limit: default 20, max 100
    const limit = Math.min(Math.max(params.limit || 20, 1), 100);

    // Build select statement - use inner join when filtering by tag
    // The !inner modifier creates INNER JOIN instead of LEFT JOIN,
    // ensuring only clients with matching tags are returned
    const selectStatement = params.tag
      ? '*, client_tags!inner(tag_name)'
      : '*, client_tags(tag_name)';

    // Build query with count for pagination
    // Filter by user ownership (assigned_to)
    let query = this.supabase
      .from('clients')
      .select(selectStatement, { count: 'exact' })
      .eq('assigned_to', userId)
      .eq('is_deleted', false)
      .order(params.sort || 'created_at', { ascending: false });

    // Cursor-based pagination using created_at
    if (params.cursor) {
      query = query.lt('created_at', params.cursor);
    }

    // Search by name or email (case-insensitive)
    if (params.search) {
      query = query.or(`name.ilike.%${params.search}%,email.ilike.%${params.search}%`);
    }

    // Filter by tag using related table filter
    if (params.tag) {
      query = query.eq('client_tags.tag_name', params.tag);
    }

    // Filter by status
    if (params.status) {
      query = query.eq('status_id', params.status);
    }

    // Apply limit last
    query = query.limit(limit);

    // Execute query
    const { data, error, count } = await query;

    if (error) {
      throw new Error(`Failed to list clients: ${error.message}`);
    }

    // Calculate next cursor from last item's created_at
    const next_cursor = data && data.length === limit
      ? data[data.length - 1].created_at
      : undefined;

    return {
      data: data || [],
      next_cursor,
      total_count: count || 0,
    };
  }

  /**
   * List clients needing follow-up (no notes in 30+ days or no notes at all)
   * Sorted by last note date (oldest first, null first)
   */
  private async listClientsNeedFollowup(params: ListClientsParams, userId: string): Promise<PaginatedClients> {
    const limit = Math.min(Math.max(params.limit || 20, 1), 100);
    const thirtyDaysAgo = new Date();
    thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);

    // Get all clients with their notes
    const { data: clientsWithNotes, error } = await this.supabase
      .from('clients')
      .select(`
        *,
        client_tags(tag_name),
        client_notes(created_at)
      `)
      .eq('assigned_to', userId)
      .eq('is_deleted', false);

    if (error) {
      throw new Error(`Failed to list clients: ${error.message}`);
    }

    // Filter and process clients
    const needFollowupClients: Array<Client & { last_note_date: string | null }> = [];

    for (const client of clientsWithNotes || []) {
      const notes = (client.client_notes as Array<{ created_at: string }>) || [];

      if (notes.length === 0) {
        // No notes at all - needs follow-up
        needFollowupClients.push({ ...client, last_note_date: null });
      } else {
        // Find the most recent note
        const sortedNotes = notes.sort(
          (a, b) => new Date(b.created_at).getTime() - new Date(a.created_at).getTime()
        );
        const latestNote = sortedNotes[0];
        if (latestNote) {
          const lastNoteDate = new Date(latestNote.created_at);
          if (lastNoteDate < thirtyDaysAgo) {
            needFollowupClients.push({ ...client, last_note_date: latestNote.created_at });
          }
        }
      }
    }

    // Sort by last_note_date (null first, then oldest)
    needFollowupClients.sort((a, b) => {
      if (a.last_note_date === null && b.last_note_date === null) return 0;
      if (a.last_note_date === null) return -1;
      if (b.last_note_date === null) return 1;
      return new Date(a.last_note_date).getTime() - new Date(b.last_note_date).getTime();
    });

    // Apply cursor-based pagination using index
    let startIndex = 0;
    if (params.cursor) {
      const cursorIndex = parseInt(params.cursor, 10);
      if (!isNaN(cursorIndex)) {
        startIndex = cursorIndex;
      }
    }

    const paginatedClients = needFollowupClients.slice(startIndex, startIndex + limit);
    const hasMore = startIndex + limit < needFollowupClients.length;

    return {
      data: paginatedClients,
      next_cursor: hasMore ? String(startIndex + limit) : undefined,
      total_count: needFollowupClients.length,
    };
  }

  /**
   * List clients with birthdays in the next 30 days
   * Sorted by days until birthday (soonest first)
   */
  private async listClientsBirthdaysSoon(params: ListClientsParams, userId: string): Promise<PaginatedClients> {
    const limit = Math.min(Math.max(params.limit || 20, 1), 100);
    const today = new Date();

    // Get all clients with birthdays
    const { data: clientsWithBirthdays, error } = await this.supabase
      .from('clients')
      .select('*, client_tags(tag_name)')
      .eq('assigned_to', userId)
      .eq('is_deleted', false)
      .not('birthday', 'is', null);

    if (error) {
      throw new Error(`Failed to list clients: ${error.message}`);
    }

    // Calculate days until birthday for each client
    const birthdaySoonClients: Array<Client & { days_until: number }> = [];

    for (const client of clientsWithBirthdays || []) {
      if (!client.birthday) continue;

      const birthday = new Date(client.birthday);
      const thisYearBirthday = new Date(
        today.getFullYear(),
        birthday.getMonth(),
        birthday.getDate()
      );

      // If birthday already passed this year, check next year
      let nextBirthday = thisYearBirthday;
      if (thisYearBirthday < today) {
        nextBirthday = new Date(
          today.getFullYear() + 1,
          birthday.getMonth(),
          birthday.getDate()
        );
      }

      // Calculate days until birthday
      const diffTime = nextBirthday.getTime() - today.getTime();
      const daysUntil = Math.ceil(diffTime / (1000 * 60 * 60 * 24));

      // Include if within 30 days
      if (daysUntil >= 0 && daysUntil <= 30) {
        birthdaySoonClients.push({ ...client, days_until: daysUntil });
      }
    }

    // Sort by days until birthday (soonest first)
    birthdaySoonClients.sort((a, b) => a.days_until - b.days_until);

    // Apply cursor-based pagination using index
    let startIndex = 0;
    if (params.cursor) {
      const cursorIndex = parseInt(params.cursor, 10);
      if (!isNaN(cursorIndex)) {
        startIndex = cursorIndex;
      }
    }

    const paginatedClients = birthdaySoonClients.slice(startIndex, startIndex + limit);
    const hasMore = startIndex + limit < birthdaySoonClients.length;

    return {
      data: paginatedClients,
      next_cursor: hasMore ? String(startIndex + limit) : undefined,
      total_count: birthdaySoonClients.length,
    };
  }

  /**
   * Get client by ID with related data counts
   *
   * Retrieves a single client record with aggregated counts of related data.
   * Verifies user ownership before returning data.
   *
   * @param id - The client ID to retrieve
   * @param userId - The authenticated user's ID (required for authorization)
   * @returns Promise<ClientWithCounts | null> The client with related counts, or null if not found
   * @throws {Error} If database query fails
   */
  async getClientById(id: string, userId: string): Promise<ClientWithCounts | null> {
    if (!userId) {
      throw new Error('User ID is required');
    }

    const { data: client, error } = await this.supabase
      .from('clients')
      .select(`
        *,
        documents:client_documents(count),
        notes:client_notes(count),
        tasks:client_tasks(count),
        tags:client_tags(tag_name)
      `)
      .eq('id', id)
      .eq('assigned_to', userId)
      .eq('is_deleted', false)
      .single();

    if (error) {
      // PGRST116 is PostgREST's "row not found" error
      if (error.code === 'PGRST116') {
        return null;
      }
      throw new Error(error.message);
    }

    // Transform aggregated counts and tags into simple properties
    const tagNames = client.tags?.map((t: { tag_name: string }) => t.tag_name) || [];

    return {
      ...client,
      documents_count: client.documents[0]?.count || 0,
      notes_count: client.notes[0]?.count || 0,
      tasks_count: client.tasks[0]?.count || 0,
      tags: tagNames,
    };
  }

  /**
   * Update client data
   *
   * Updates one or more fields of an existing client record.
   * Verifies user ownership before updating.
   *
   * @param id - The client ID to update
   * @param data - Partial client data to update
   * @param userId - The authenticated user's ID (required for authorization)
   * @returns Promise<Client | null> The updated client, or null if not found
   * @throws {Error} If database query fails
   */
  async updateClient(id: string, data: UpdateClientInput, userId: string): Promise<Client | null> {
    if (!userId) {
      throw new Error('User ID is required');
    }

    // Extract tags from data (they're not part of the clients table)
    const { tags, ...clientData } = data;

    // Check if there are any client fields to update
    const hasClientDataToUpdate = Object.keys(clientData).length > 0;

    let client: Client | null = null;

    if (hasClientDataToUpdate) {
      // Update client table fields if provided
      const { data: updatedClient, error } = await this.supabase
        .from('clients')
        .update(clientData)
        .eq('id', id)
        .eq('assigned_to', userId)
        .eq('is_deleted', false)
        .select()
        .single();

      if (error) {
        // PGRST116 is PostgREST's "row not found" error
        if (error.code === 'PGRST116') {
          return null;
        }
        throw new Error(error.message);
      }

      client = updatedClient;
    } else {
      // If only tags are being updated, fetch the client to verify ownership
      const { data: existingClient, error } = await this.supabase
        .from('clients')
        .select()
        .eq('id', id)
        .eq('assigned_to', userId)
        .eq('is_deleted', false)
        .single();

      if (error) {
        if (error.code === 'PGRST116') {
          return null;
        }
        throw new Error(error.message);
      }

      client = existingClient;
    }

    // Handle tags if provided
    if (tags !== undefined && client) {
      // Delete existing tags
      await this.supabase
        .from('client_tags')
        .delete()
        .eq('client_id', id);

      // Add new tags if any
      if (tags.length > 0) {
        const tagRecords = tags.map((tagName: string) => ({
          client_id: client.id,
          tag_name: tagName,
          created_by: userId,
        }));

        const { error: tagError } = await this.supabase
          .from('client_tags')
          .insert(tagRecords);

        if (tagError) {
          // Log error but don't fail the request (tags are optional)
          console.error('Failed to update tags:', tagError);
        }
      }
    }

    return client;
  }

  /**
   * Soft delete a client
   *
   * Marks a client as deleted by setting is_deleted = true.
   * Verifies user ownership before deleting.
   *
   * @param id - The client ID to soft delete
   * @param userId - The authenticated user's ID (required for authorization)
   * @returns Promise<boolean> True if deletion succeeded
   * @throws {Error} If database query fails
   */
  /**
   * Bulk create clients from CSV import
   *
   * Inserts clients one-by-one to handle individual duplicate errors gracefully.
   * Auto-creates missing tags in user_tags before assigning them.
   *
   * @param clients - Array of client data to create
   * @param userId - The authenticated user's ID
   * @returns Object with created clients and per-row errors
   */
  async createClientsBulk(
    clients: CreateClientInput[],
    userId: string
  ): Promise<{
    created: Client[];
    errors: Array<{ index: number; error: string }>;
  }> {
    if (!userId) {
      throw new Error('User ID is required');
    }

    // Collect all unique tag names from the batch
    const allTagNames = new Set<string>();
    clients.forEach((client) => {
      client.tags?.forEach((tag) => allTagNames.add(tag));
    });

    // Auto-create missing tags in user_tags
    if (allTagNames.size > 0) {
      const { data: existingTags } = await this.supabase
        .from('user_tags')
        .select('name')
        .eq('user_id', userId);

      const existingTagNames = new Set(
        existingTags?.map((t: { name: string }) => t.name) || []
      );

      const newTags = Array.from(allTagNames).filter(
        (name) => !existingTagNames.has(name)
      );

      if (newTags.length > 0) {
        const tagRecords = newTags.map((name) => ({
          user_id: userId,
          name,
          color: '#6B7280', // Default gray
        }));

        await this.supabase.from('user_tags').insert(tagRecords);
      }
    }

    // Insert clients one-by-one
    const created: Client[] = [];
    const errors: Array<{ index: number; error: string }> = [];

    for (let i = 0; i < clients.length; i++) {
      try {
        const client = await this.createClient(clients[i]!, userId);
        created.push(client);
      } catch (error) {
        errors.push({
          index: i,
          error: error instanceof Error ? error.message : 'Unknown error',
        });
      }
    }

    return { created, errors };
  }

  async softDeleteClient(id: string, userId: string): Promise<boolean> {
    if (!userId) {
      throw new Error('User ID is required');
    }

    const { error } = await this.supabase
      .from('clients')
      .update({ is_deleted: true })
      .eq('id', id)
      .eq('assigned_to', userId)
      .eq('is_deleted', false);

    if (error) {
      throw new Error(error.message);
    }

    return true;
  }
}
