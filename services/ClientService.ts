import { createClient } from '@supabase/supabase-js';
import type {
  Client,
  ClientWithCounts,
  CreateClientInput,
  UpdateClientInput,
  ListClientsParams,
  PaginatedClients
} from '@/lib/types/client';

// Initialize Supabase client at module level
const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
);

/**
 * ClientService handles all client-related database operations
 *
 * Features:
 * - CRUD operations for client records
 * - Cursor-based pagination for efficient list queries
 * - Full-text search across client fields
 * - Tag-based filtering
 * - Soft delete with RLS policy enforcement
 *
 * Uses Supabase for data persistence with Row Level Security (RLS) policies
 * ensuring users can only access their own clients.
 *
 * @example
 * ```typescript
 * const clientService = new ClientService();
 *
 * // Create a new client
 * const client = await clientService.createClient({
 *   name: "John Doe",
 *   email: "john@example.com"
 * });
 *
 * // List clients with pagination
 * const result = await clientService.listClients({ limit: 20 });
 * ```
 */
export class ClientService {
  private supabase = supabase;

  /**
   * Initialize ClientService
   *
   * @throws {Error} If Supabase credentials are not configured
   */
  constructor() {
    if (!process.env.NEXT_PUBLIC_SUPABASE_URL || !process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY) {
      throw new Error('Supabase credentials not configured. Please check your environment variables.');
    }
  }

  /**
   * Create a new client
   *
   * @param data - Client data to create
   * @returns Promise<Client> The created client record
   * @throws {Error} If user is not authenticated
   * @throws {Error} If email or phone already exists
   * @throws {Error} If database operation fails
   *
   * @example
   * ```typescript
   * const client = await clientService.createClient({
   *   name: "John Doe",
   *   email: "john@example.com",
   *   phone: "+1-555-123-4567"
   * });
   * ```
   */
  async createClient(data: CreateClientInput): Promise<Client> {
    // Get authenticated user from Supabase auth
    const { data: userData, error: authError } = await this.supabase.auth.getUser();

    if (authError || !userData.user) {
      throw new Error('Not authenticated');
    }

    // Insert client into database (UUID auto-generated by PostgreSQL)
    const { data: client, error } = await this.supabase
      .from('clients')
      .insert({
        ...data,
        created_by: userData.user.id,
        assigned_to: userData.user.id,
        is_deleted: false,
      })
      .select()
      .single();

    if (error) {
      // Check for unique constraint violation (duplicate email/phone)
      if (error.code === '23505') {
        throw new Error('Email or phone already exists');
      }
      throw new Error(error.message);
    }

    return client;
  }

  /**
   * List clients with pagination, search, and filtering
   *
   * Supports cursor-based pagination for efficient browsing of large datasets.
   * Results are automatically filtered to exclude soft-deleted clients and
   * respect Row Level Security (RLS) policies.
   *
   * @param params - Query parameters for filtering and pagination
   * @param params.cursor - Pagination cursor (created_at timestamp from previous page)
   * @param params.limit - Items per page (default: 20, max: 100)
   * @param params.search - Search term for name or email (case-insensitive)
   * @param params.tag - Filter by tag name
   * @param params.sort - Sort field: 'created_at' (default) or 'name'
   *
   * @returns Promise<PaginatedClients> Paginated client list with total count and next cursor
   * @throws {Error} If database query fails
   *
   * @example
   * ```typescript
   * // Basic pagination
   * const result = await clientService.listClients({ limit: 20 });
   *
   * // With cursor for next page
   * const nextPage = await clientService.listClients({
   *   cursor: result.next_cursor,
   *   limit: 20
   * });
   *
   * // Search by name or email
   * const searchResults = await clientService.listClients({
   *   search: 'john',
   *   limit: 10
   * });
   *
   * // Filter by tag
   * const vipClients = await clientService.listClients({
   *   tag: 'VIP',
   *   limit: 50
   * });
   *
   * // Combine filters
   * const filtered = await clientService.listClients({
   *   search: 'smith',
   *   tag: 'VIP',
   *   sort: 'name',
   *   limit: 25
   * });
   * ```
   */
  async listClients(params: ListClientsParams): Promise<PaginatedClients> {
    // Validate and enforce limit: default 20, max 100
    const limit = Math.min(Math.max(params.limit || 20, 1), 100);

    // Build query with count for pagination
    let query = this.supabase
      .from('clients')
      .select('*, client_tags(tag_name)', { count: 'exact' })
      .eq('is_deleted', false)
      .order(params.sort || 'created_at', { ascending: false });

    // Cursor-based pagination using created_at
    if (params.cursor) {
      query = query.lt('created_at', params.cursor);
    }

    // Search by name or email (case-insensitive)
    if (params.search) {
      query = query.or(`name.ilike.%${params.search}%,email.ilike.%${params.search}%`);
    }

    // Filter by tag
    if (params.tag) {
      query = query.contains('client_tags', [{ tag_name: params.tag }]);
    }

    // Apply limit last
    query = query.limit(limit);

    // Execute query
    const { data, error, count } = await query;

    if (error) {
      throw new Error(`Failed to list clients: ${error.message}`);
    }

    // Calculate next cursor from last item's created_at
    // Only include cursor if we returned a full page (indicating more data may exist)
    const next_cursor = data && data.length === limit
      ? data[data.length - 1].created_at
      : undefined;

    return {
      data: data || [],
      next_cursor,
      total_count: count || 0,
    };
  }

  /**
   * Get client by ID with related data counts
   *
   * Retrieves a single client record with aggregated counts of related data:
   * - documents_count: Number of documents attached to this client
   * - notes_count: Number of notes recorded for this client
   * - tasks_count: Number of tasks associated with this client
   *
   * Returns null for non-existent clients or soft-deleted clients.
   * Row Level Security (RLS) policies ensure users can only access their own clients.
   *
   * @param id - The client ID to retrieve
   * @returns Promise<ClientWithCounts | null> The client with related counts, or null if not found
   * @throws {Error} If database query fails (non-404 errors)
   *
   * @example
   * ```typescript
   * const client = await clientService.getClientById('client_123');
   *
   * if (client) {
   *   console.log(`Client: ${client.name}`);
   *   console.log(`Documents: ${client.documents_count}`);
   *   console.log(`Notes: ${client.notes_count}`);
   *   console.log(`Tasks: ${client.tasks_count}`);
   * } else {
   *   console.log('Client not found');
   * }
   * ```
   */
  async getClientById(id: string): Promise<ClientWithCounts | null> {
    const { data: client, error } = await this.supabase
      .from('clients')
      .select(`
        *,
        documents:client_documents(count),
        notes:client_notes(count),
        tasks:client_tasks(count)
      `)
      .eq('id', id)
      .eq('is_deleted', false)
      .single();

    if (error) {
      // PGRST116 is PostgREST's "row not found" error
      if (error.code === 'PGRST116') {
        return null;
      }
      throw new Error(error.message);
    }

    // Transform aggregated counts into simple numeric properties
    return {
      ...client,
      documents_count: client.documents[0]?.count || 0,
      notes_count: client.notes[0]?.count || 0,
      tasks_count: client.tasks[0]?.count || 0,
    };
  }

  /**
   * Update client data
   *
   * Updates one or more fields of an existing client record.
   * Only provided fields are updated; omitted fields remain unchanged.
   *
   * Returns null for non-existent clients or soft-deleted clients.
   * Row Level Security (RLS) policies ensure users can only update their own clients.
   *
   * @param id - The client ID to update
   * @param data - Partial client data to update (validated by updateClientSchema)
   * @returns Promise<Client | null> The updated client, or null if not found
   * @throws {Error} If database query fails (non-404 errors)
   *
   * @example
   * ```typescript
   * // Update single field
   * const updated = await clientService.updateClient('client_123', {
   *   phone: '+1-555-999-8888'
   * });
   *
   * // Update multiple fields
   * const updated = await clientService.updateClient('client_123', {
   *   name: 'Jane Smith Updated',
   *   email: 'jane.updated@example.com',
   *   address: '456 Oak Ave, New York, NY 10001'
   * });
   *
   * if (updated) {
   *   console.log('Client updated successfully');
   * } else {
   *   console.log('Client not found');
   * }
   * ```
   */
  async updateClient(id: string, data: UpdateClientInput): Promise<Client | null> {
    const { data: client, error } = await this.supabase
      .from('clients')
      .update(data)
      .eq('id', id)
      .eq('is_deleted', false)
      .select()
      .single();

    if (error) {
      // PGRST116 is PostgREST's "row not found" error
      if (error.code === 'PGRST116') {
        return null;
      }
      throw new Error(error.message);
    }

    return client;
  }

  /**
   * Soft delete a client
   *
   * Marks a client as deleted by setting is_deleted = true.
   * This is a SOFT DELETE - the record remains in the database for audit purposes
   * but will be filtered out from all queries.
   *
   * NEVER performs hard deletion (DELETE FROM) - this ensures GDPR compliance
   * and maintains referential integrity with related records.
   *
   * Returns true on success, or throws an error if the operation fails.
   * Row Level Security (RLS) policies ensure users can only delete their own clients.
   *
   * @param id - The client ID to soft delete
   * @returns Promise<boolean> True if deletion succeeded
   * @throws {Error} If database query fails
   *
   * @example
   * ```typescript
   * try {
   *   await clientService.softDeleteClient('client_123');
   *   console.log('Client soft deleted successfully');
   *
   *   // Client still exists in database but is_deleted = true
   *   // It will not appear in listClients() or getClientById() results
   * } catch (error) {
   *   console.error('Failed to delete client:', error.message);
   * }
   * ```
   */
  async softDeleteClient(id: string): Promise<boolean> {
    const { error } = await this.supabase
      .from('clients')
      .update({ is_deleted: true })
      .eq('id', id)
      .eq('is_deleted', false);

    if (error) {
      throw new Error(error.message);
    }

    return true;
  }
}
