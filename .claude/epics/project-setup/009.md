---
name: environment-validation-health-check
status: complete
created: 2026-01-07T02:57:01Z
updated: 2026-01-07T02:57:01Z
github: null
depends_on: [004, 005, 006, 007, 008]
parallel: false
conflicts_with: []
---

# Task: Create environment variable validation and health check endpoint

## Description

Implement type-safe environment variable validation using Zod schema, create a comprehensive health check endpoint that verifies all external services (database, storage, email, monitoring), and ensure all environment variables are properly validated on application startup.

## Acceptance Criteria

- [ ] Environment schema defined in `lib/env.ts` with Zod
- [ ] All required environment variables validated
- [ ] Type-safe environment access throughout codebase
- [ ] Health check endpoint created at `app/api/health/route.ts`
- [ ] Health check tests database connectivity
- [ ] Health check tests storage service
- [ ] Health check tests email service
- [ ] Health check tests Sentry connection
- [ ] Detailed health status response with individual service checks
- [ ] Environment validation runs on app startup

## Technical Details

### Implementation Steps

**1. Create Environment Validation Schema**

```typescript
// lib/env.ts
import { z } from 'zod';

// Define schema for all environment variables
const envSchema = z.object({
  // App Configuration
  NODE_ENV: z.enum(['development', 'production', 'test']).default('development'),
  APP_URL: z.string().url().default('http://localhost:3000'),

  // Supabase
  SUPABASE_URL: z.string().url(),
  SUPABASE_ANON_KEY: z.string().min(1),
  SUPABASE_DATABASE_URL: z.string().min(1),

  // Google OAuth
  GOOGLE_CLIENT_ID: z.string().min(1),
  GOOGLE_CLIENT_SECRET: z.string().min(1),

  // Resend Email
  RESEND_API_KEY: z.string().startsWith('re_'),
  RESEND_FROM_EMAIL: z.string().email().default('onboarding@resend.dev'),

  // Sentry Monitoring
  SENTRY_DSN: z.string().url().optional(),
  NEXT_PUBLIC_SENTRY_DSN: z.string().url().optional(),
  SENTRY_AUTH_TOKEN: z.string().optional(),
  SENTRY_ORG: z.string().optional(),
  SENTRY_PROJECT: z.string().optional(),

  // Authentication
  JWT_SECRET: z.string().min(32),

  // Vercel (optional, set automatically in production)
  VERCEL_URL: z.string().optional(),
  VERCEL_ENV: z.enum(['development', 'preview', 'production']).optional(),
  VERCEL_GIT_COMMIT_SHA: z.string().optional(),
});

// Infer TypeScript type from schema
export type Env = z.infer<typeof envSchema>;

// Parse and validate environment variables
function validateEnv(): Env {
  const parsed = envSchema.safeParse(process.env);

  if (!parsed.success) {
    console.error('âŒ Invalid environment variables:');
    console.error(JSON.stringify(parsed.error.format(), null, 2));
    throw new Error('Invalid environment variables');
  }

  return parsed.data;
}

// Export validated environment variables
export const env = validateEnv();

// Helper to check if running in production
export const isProduction = env.NODE_ENV === 'production';

// Helper to check if running in development
export const isDevelopment = env.NODE_ENV === 'development';

// Helper to check if running in test
export const isTest = env.NODE_ENV === 'test';

// Helper to get app URL
export const getAppUrl = (): string => {
  if (env.VERCEL_URL && env.VERCEL_ENV === 'preview') {
    return `https://${env.VERCEL_URL}`;
  }
  return env.APP_URL;
};
```

**2. Create Environment Validation Middleware**

```typescript
// lib/validate-env.ts
import { env } from './env';

/**
 * Validates environment variables on application startup
 * Call this in instrumentation.ts or root layout
 */
export function validateEnvironment(): void {
  console.log('ðŸ” Validating environment variables...');

  try {
    // Access env to trigger validation
    const requiredVars = [
      'SUPABASE_URL',
      'SUPABASE_ANON_KEY',
      'SUPABASE_DATABASE_URL',
      'GOOGLE_CLIENT_ID',
      'GOOGLE_CLIENT_SECRET',
      'RESEND_API_KEY',
      'JWT_SECRET',
    ];

    requiredVars.forEach((varName) => {
      if (!env[varName as keyof typeof env]) {
        throw new Error(`Missing required environment variable: ${varName}`);
      }
    });

    console.log('âœ… Environment variables validated successfully');
  } catch (error) {
    console.error('âŒ Environment validation failed:', error);
    throw error;
  }
}
```

**3. Add Validation to Instrumentation**

```typescript
// instrumentation.ts (update existing file)
import { validateEnvironment } from './lib/validate-env';

export async function register() {
  // Validate environment before initializing Sentry
  validateEnvironment();

  if (process.env.NEXT_RUNTIME === 'nodejs') {
    await import('./sentry.server.config');
  }

  if (process.env.NEXT_RUNTIME === 'edge') {
    await import('./sentry.edge.config');
  }
}

export const onRequestError = async (err: Error, request: Request, context: any) => {
  await import('./sentry.server.config');
  const Sentry = await import('@sentry/nextjs');
  Sentry.captureException(err, {
    contexts: {
      request: {
        url: request.url,
        method: request.method,
        headers: Object.fromEntries(request.headers.entries()),
      },
    },
  });
};
```

**4. Create Health Check Endpoint**

```typescript
// app/api/health/route.ts
import { NextResponse } from 'next/server';
import { createClient } from '@/lib/supabase/server';
import { StorageService } from '@/lib/storage';
import { EmailService } from '@/lib/email';
import { env, isProduction } from '@/lib/env';
import * as Sentry from '@sentry/nextjs';

interface ServiceStatus {
  status: 'healthy' | 'degraded' | 'unhealthy';
  message?: string;
  latency?: number;
  error?: string;
}

interface HealthCheckResponse {
  status: 'healthy' | 'degraded' | 'unhealthy';
  timestamp: string;
  environment: string;
  services: {
    database: ServiceStatus;
    storage: ServiceStatus;
    email: ServiceStatus;
    monitoring: ServiceStatus;
  };
  system: {
    uptime: number;
    memory: {
      used: number;
      total: number;
      percentage: number;
    };
  };
}

async function checkDatabase(): Promise<ServiceStatus> {
  const start = Date.now();
  try {
    const supabase = createClient();
    const { error } = await supabase.from('users').select('id').limit(1);

    if (error) {
      return {
        status: 'unhealthy',
        error: error.message,
        latency: Date.now() - start,
      };
    }

    return {
      status: 'healthy',
      message: 'Database connection successful',
      latency: Date.now() - start,
    };
  } catch (error) {
    return {
      status: 'unhealthy',
      error: error instanceof Error ? error.message : 'Unknown error',
      latency: Date.now() - start,
    };
  }
}

async function checkStorage(): Promise<ServiceStatus> {
  const start = Date.now();
  try {
    const supabase = createClient();
    const { data, error } = await supabase.storage.from('client-documents').list('', { limit: 1 });

    if (error) {
      return {
        status: 'unhealthy',
        error: error.message,
        latency: Date.now() - start,
      };
    }

    return {
      status: 'healthy',
      message: 'Storage service accessible',
      latency: Date.now() - start,
    };
  } catch (error) {
    return {
      status: 'unhealthy',
      error: error instanceof Error ? error.message : 'Unknown error',
      latency: Date.now() - start,
    };
  }
}

async function checkEmail(): Promise<ServiceStatus> {
  const start = Date.now();
  try {
    // In production, skip actual email send to avoid quota usage
    // Just verify API key is configured
    if (isProduction) {
      if (!env.RESEND_API_KEY) {
        return {
          status: 'unhealthy',
          error: 'RESEND_API_KEY not configured',
          latency: Date.now() - start,
        };
      }

      return {
        status: 'healthy',
        message: 'Email service configured',
        latency: Date.now() - start,
      };
    }

    // In development, we could test actual send to a test address
    // For now, just check configuration
    return {
      status: 'healthy',
      message: 'Email service configured',
      latency: Date.now() - start,
    };
  } catch (error) {
    return {
      status: 'unhealthy',
      error: error instanceof Error ? error.message : 'Unknown error',
      latency: Date.now() - start,
    };
  }
}

async function checkMonitoring(): Promise<ServiceStatus> {
  const start = Date.now();
  try {
    if (!env.SENTRY_DSN) {
      return {
        status: 'degraded',
        message: 'Sentry not configured (optional)',
        latency: Date.now() - start,
      };
    }

    // Test Sentry by capturing a test message
    Sentry.captureMessage('Health check test', 'debug');

    return {
      status: 'healthy',
      message: 'Monitoring service active',
      latency: Date.now() - start,
    };
  } catch (error) {
    return {
      status: 'degraded',
      error: error instanceof Error ? error.message : 'Unknown error',
      latency: Date.now() - start,
    };
  }
}

function getSystemInfo() {
  const usage = process.memoryUsage();
  return {
    uptime: process.uptime(),
    memory: {
      used: Math.round(usage.heapUsed / 1024 / 1024), // MB
      total: Math.round(usage.heapTotal / 1024 / 1024), // MB
      percentage: Math.round((usage.heapUsed / usage.heapTotal) * 100),
    },
  };
}

export async function GET() {
  try {
    // Run all health checks in parallel
    const [database, storage, email, monitoring] = await Promise.all([
      checkDatabase(),
      checkStorage(),
      checkEmail(),
      checkMonitoring(),
    ]);

    // Determine overall status
    const services = { database, storage, email, monitoring };
    const statuses = Object.values(services).map((s) => s.status);

    let overallStatus: 'healthy' | 'degraded' | 'unhealthy';
    if (statuses.includes('unhealthy')) {
      overallStatus = 'unhealthy';
    } else if (statuses.includes('degraded')) {
      overallStatus = 'degraded';
    } else {
      overallStatus = 'healthy';
    }

    const response: HealthCheckResponse = {
      status: overallStatus,
      timestamp: new Date().toISOString(),
      environment: env.NODE_ENV,
      services,
      system: getSystemInfo(),
    };

    // Return appropriate HTTP status code
    const statusCode = overallStatus === 'healthy' ? 200 : overallStatus === 'degraded' ? 200 : 503;

    return NextResponse.json(response, { status: statusCode });
  } catch (error) {
    console.error('Health check error:', error);
    Sentry.captureException(error);

    return NextResponse.json(
      {
        status: 'unhealthy',
        timestamp: new Date().toISOString(),
        environment: env.NODE_ENV,
        error: error instanceof Error ? error.message : 'Unknown error',
      },
      { status: 503 }
    );
  }
}
```

**5. Update Package.json Scripts**

```json
// package.json - add validation script
{
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint",
    "type-check": "tsc --noEmit",
    "validate-env": "node -r dotenv/config -e 'require(\"./lib/env\").env'",
    "health-check": "curl -s http://localhost:3000/api/health | jq"
  }
}
```

**6. Create Health Check Script**

```bash
#!/bin/bash
# scripts/health-check.sh

echo "ðŸ¥ Running health check..."

# Make request to health endpoint
RESPONSE=$(curl -s http://localhost:3000/api/health)

# Parse response
STATUS=$(echo $RESPONSE | jq -r '.status')

if [ "$STATUS" = "healthy" ]; then
  echo "âœ… All services healthy"
  echo $RESPONSE | jq
  exit 0
elif [ "$STATUS" = "degraded" ]; then
  echo "âš ï¸  Some services degraded"
  echo $RESPONSE | jq
  exit 0
else
  echo "âŒ Services unhealthy"
  echo $RESPONSE | jq
  exit 1
fi
```

**7. Update .env.example with All Variables**

```bash
# Update .env.example to include all validated variables
cat > .env.example << 'EOF'
# Application
NODE_ENV=development
APP_URL=http://localhost:3000

# Supabase
SUPABASE_URL=https://your-project.supabase.co
SUPABASE_ANON_KEY=your-anon-key
SUPABASE_DATABASE_URL=postgresql://postgres:[password]@db.your-project.supabase.co:5432/postgres

# Google OAuth
GOOGLE_CLIENT_ID=your-google-client-id
GOOGLE_CLIENT_SECRET=your-google-client-secret

# Resend Email
RESEND_API_KEY=re_your_api_key
RESEND_FROM_EMAIL=onboarding@resend.dev

# Sentry Monitoring (optional)
SENTRY_DSN=https://xxx@xxx.ingest.sentry.io/xxx
NEXT_PUBLIC_SENTRY_DSN=https://xxx@xxx.ingest.sentry.io/xxx
SENTRY_AUTH_TOKEN=your_auth_token
SENTRY_ORG=your-org
SENTRY_PROJECT=your-project

# Authentication
JWT_SECRET=your-jwt-secret-minimum-32-characters-long

# Vercel (auto-set in production)
# VERCEL_URL=auto-generated
# VERCEL_ENV=auto-generated
# VERCEL_GIT_COMMIT_SHA=auto-generated
EOF
```

### Key Files Created/Modified

- `lib/env.ts` - Environment variable schema and validation
- `lib/validate-env.ts` - Validation helper
- `app/api/health/route.ts` - Health check endpoint
- `instrumentation.ts` - Add environment validation
- `package.json` - Add validation scripts
- `scripts/health-check.sh` - Health check script
- `.env.example` - Complete environment variable template

## Dependencies

### Depends On

- Task 004: Supabase client setup (for database check)
- Task 005: Storage service (for storage check)
- Task 006: Google OAuth (for environment validation)
- Task 007: Email and Sentry (for service checks)
- Task 008: Vercel CLI (for environment variable patterns)

### Blocks

- Task 010: Final integration testing needs health check endpoint

## Effort Estimate

- **Size**: M
- **Hours**: 2-3 hours
- **Parallel**: false (must wait for all service setup tasks)

## Definition of Done

- [x] Environment schema defined with Zod
- [x] All required variables validated on startup
- [x] Type-safe env access available
- [x] Health check endpoint returns detailed status
- [x] Database connectivity verified
- [x] Storage service verified
- [x] Email service verified
- [x] Monitoring service verified
- [x] .env.example complete and up-to-date

## Validation Commands

```bash
# Test environment validation
npm run validate-env
# Expected: âœ… Environment variables validated successfully

# Start dev server (will validate env on startup)
npm run dev
# Expected:
# ðŸ” Validating environment variables...
# âœ… Environment variables validated successfully

# Test health check endpoint
curl http://localhost:3000/api/health | jq

# Expected response:
# {
#   "status": "healthy",
#   "timestamp": "2026-01-07T02:57:01Z",
#   "environment": "development",
#   "services": {
#     "database": {
#       "status": "healthy",
#       "message": "Database connection successful",
#       "latency": 45
#     },
#     "storage": {
#       "status": "healthy",
#       "message": "Storage service accessible",
#       "latency": 32
#     },
#     "email": {
#       "status": "healthy",
#       "message": "Email service configured",
#       "latency": 12
#     },
#     "monitoring": {
#       "status": "healthy",
#       "message": "Monitoring service active",
#       "latency": 8
#     }
#   },
#   "system": {
#     "uptime": 123.45,
#     "memory": {
#       "used": 256,
#       "total": 512,
#       "percentage": 50
#     }
#   }
# }

# Run health check script
chmod +x scripts/health-check.sh
./scripts/health-check.sh
# Expected: âœ… All services healthy

# Test with missing env var
mv .env.local .env.local.backup
npm run dev
# Expected: âŒ Invalid environment variables
# (Error listing missing variables)
mv .env.local.backup .env.local
```

## Troubleshooting

**Issue: "Invalid environment variables" on startup**

- Check all required variables are in `.env.local`
- Compare `.env.local` with `.env.example`
- Verify no typos in variable names
- Check for missing values

**Issue: Health check returns 503**

- Check which service is unhealthy in response
- Verify service credentials are correct
- Test individual services separately
- Check network connectivity

**Issue: Database check fails**

- Verify `SUPABASE_DATABASE_URL` is correct
- Check database is accessible
- Verify RLS policies allow access
- Test with `psql` or Supabase dashboard

**Issue: Storage check fails**

- Verify storage bucket "client-documents" exists
- Check storage configuration in Supabase
- Verify RLS policies for storage

**Issue: Type errors with env variables**

- Import from `lib/env` not `process.env`
- Use: `import { env } from '@/lib/env'`
- Then: `env.SUPABASE_URL` (type-safe)

## Next Steps

After completing this task:

1. Add health check to CI/CD pipeline
2. Set up uptime monitoring (Vercel, UptimeRobot)
3. Configure alerts for service degradation
4. Add more detailed service checks as needed
5. Create health check dashboard
6. Set up automated health check tests
